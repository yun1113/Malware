from __future__ import absolute_import

from django.conf import settings
from django.core.files.base import ContentFile
from django.utils.timezone import datetime

from malwaredb.models import Malware, Hooklog, VirusTotal, VirusTotalInfo

from celery import shared_task
from celery.exceptions import SoftTimeLimitExceeded
import requests
import json
import dockemport os
import time

BASE_DIR = settings.BASE_DIR


@shared_task(soft_time_limit=7200)
def profiling(hash_value, streaming=False, server_ip=settings.LOCAL_IP, server_port="10001"):
    try: 
        print("Step0. Get Virustotal Data")
        virustotal_data = get_virustotal_data(hash_value)
        update_virustotal_data(hash_value, virustotal_data)

        for i in range(3):  # try three times

            print("Step1. Create Client")
            client = docker.APIClient(base_url='unix://var/run/docker.sock', version='1.21')

            print("Step2. Create container")
            container = client.create_container(image=settings.DOCKER_IMAGE, stdin_open=True, tty=True,
                                                command="./home/root/automation/script/profiling.sh {0} {1} {2} {3}".format(
                                                    hash_value, "true" if streaming else "false", server_ip, server_port),
                                                volumes=['/home/root/VMimage', '/home/root/malware',
                                                         '/home/root/automation', '/home/root/malwaredb'],
                                                host_config=client.create_host_config(privileged=True, binds=[
                                                    BASE_DIR + '/VMimage:/home/root/VMimage',
                                                    BASE_DIR + '/media/uploads:/home/root/malware',
                                                    BASE_DIR + '/automation:/home/root/automation',
                                                    BASE_DIR + '/malwaredb:/home/root/malwaredb']))

            print("Step3. Start Container")
            client.start(container)

            print("Step4. After 10 mins...")
            time.sleep(600)  # 10 min

            while len(client.containers(filters={'id': container['Id']})) != 0:
                print("Step5. After more 1 min...")
                time.sleep(60)

            create_hooklog_state = save_hooklog_in_db(hash_value)
            if create_hooklog_state:
                Malware.objects.filter(hash=hash_value).update(create_hooklog_state=create_hooklog_state)
                print("Step6. Remove Container")
                client.remove_container(container['Id'])
                break
            else:
                print("Step6. Excute Log")
                with open(BASE_DIR + "/malwaredb/docker_logs/"+container['Id']+"_"+str(i), "w") as f:
                    f.write(client.logs(container))
                print("Step7. Remove Container")
                client.remove_container(container['Id'])
    except SoftTimeLimitExceeded:
         print("Excute out of time")
         client.remove_container(container['Id'], force=True)


def save_hooklog_in_db(hash_value):
    success = False
    output_path = BASE_DIR + "/automation/output/"
   
    for filename in os.listdir(output_path):
        if hash_value in filename and ".hooklog" in filename:
            # update hooklog model
            with open(output_path + filename, "r") as f:
                malware = Malware.objects.get(hash=hash_value)
                content = f.read().decode('ISO 8859-1').strip()
                fix_content = save_simplified_trace(content, filename)
                hooklog, created = Hooklog.objects.get_or_create(hooklog=fix_content, malware=malware)
                f.seek(0)
                hooklog.hooklog_file.save(filename, f)

            success = True
    return success


def save_simplified_trace(content, filename):
    out_file_path = BASE_DIR + "/media/trace_simplified/"
    api_selected_dict = {
        'LoadLibrary': {'lpFileName'},
        'CreateProcess': {'lpApplicationName', 'lpCommandLine', 'lpCurrentDirectory'},
        'OpenProcess': {'dwProcessId'},
        'ExitProcess': {'uExitCode'},
        'WinExec': {'lpCmdLine'},
        'CloseHandle': {'hObject'},
        'CreateRemoteThread': {'hProcess', 'lpParameter', 'dwCreationFlags', 'lpThreadId'},
        'TerminateProcess': {'hProcess', 'uExitCode'},
        'TerminateThread': {'hThread', 'dwExitCode'},
        'CreateThread': {'lpStartAddress', 'lpParameter', 'dwCreationFlags', 'lpThreadId'},
        'OpenThread': {'dwDesiredAccess', 'dwThreadId'},
        'CopyFile': {'lpExistingFileName', 'lpNewFileName'},
        'CreateFile': {'lpFileName', 'dwDesiredAccess', 'dwShareMode', 'dwCreationDisposition'},
        'WriteFile': {'hFile'},
        'ReadFile': {'hFile'},
        'DeleteFile': {'lpFileName'},
        'RegOpenCurrentUser': {},
        'RegOpenKey': {'hKey', 'lpSubKey', 'phkResult'},
        'RegCloseKey': {'hKey'},
        'RegSetValue': {'hKey', 'lpSubKey', 'dwType', 'lpData'},
        'RegCreateKey': {'hKey', 'lpSubKey', 'phkResult'},
        'RegDeleteKey': {'hKey', 'lpSubKey'},
        'RegDeleteValue': {'hKey', 'lpValueName'},
        'RegQueryValue': {'hKey', 'lpValueName', 'lpType', 'lpData'},
        'RegEnumValue': {'hKey', 'lpValueName', 'lpType', 'lpData'},
        'WinHttpConnect': {'pswzServerName', 'nServerPort'},
        'WinHttpCreateUrl': {'pwszUrl'},
        'WinHttpOpen':{'pwszUserAgent'},
        'WinHttpOpenRequest': {'pwszObjectName'},
        'WinHttpReadData': {'lpBuffer'},
        'WinHttpSendRequest': {'pwszHeaders'},
        'WinHttpWriteData': {'lpBuffer'},
        'WinHttpGetProxyForUrl': {'lpcwszUrl'},
        'InternetOpen': {'lpszAgent'},
        'InternetConnect': {'lpszServerName'},
        'HttpSendRequest': {'lpszHeaders'},
        'GetUrlCacheEntryInfo': {'lpszUrlName'},
    }

        
    lines = content.split('\n#')

    header = lines[0] + '\n'
    new_lines = [header, ]
    fix_lines = [header, ]
    for l in lines[1:]:
        api_infos = l.split('\n')

        time_stamp = api_infos[0]
        api_name = api_infos[1]

        _selparameter = []
        _allparameter = []
        for parameter in api_infos[2:]:
            parameter_name = parameter.split('=')[0].strip()
            if api_name == 'CreateThread' and parameter_name == 'dwThreadId':
                parameter.replace('dwThreadId', 'lpThreadId')
            if api_name == 'RegSetValue' and parameter_name == 'lpType':
                parameter.replace('lpType', 'dwType')
            if parameter_name in api_selected_dict[api_name] or parameter_name in ['EAX', 'Return']:
                _selparameter.append(parameter)
            _allparameter.append(parameter)

        new_lines.append('#' + time_stamp + '\n' + api_name + '\n' + '\n'.join(_selparameter)  + '\n')
        fix_lines.append('#' + time_stamp + '\n' + api_name + '\n' + '\n'.join(_allparameter)  + '\n')

    new_content = ''.join(new_lines)
    fix_content = ''.join(fix_lines)

    with open(out_file_path + filename, 'w') as fo:
        fo.write(new_content.encode('ISO 8859-1'))
    
    return fix_content

def get_virustotal_data(malware_hash):

    # get malware data from virus total
    url = "https://www.virustotal.com/vtapi/v2/file/report"
    parameters = {"resource": malware_hash, "apikey": settings.VIRUSTOTAL_KEY}

    response = requests.post(url, data=parameters)
    result = response.content

    return result

def update_virustotal_data(malware_hash, result):
    # add/update malware data to virus total table
    malware = Malware.objects.get(hash=malware_hash)
    virus_total, created = VirusTotal.objects.update_or_create(malware=malware, defaults={'virus_total': result})
    if created:
        virus_total.virus_total_file.save(malware_hash, ContentFile(result))
    elif result != virus_total.virus_total:
        with open(virus_total.virus_total_file.path, 'w') as f:
            f.write(result)

    virus_total.save()

    # update malware data
    virustotal_info = json.loads(result)
    if virustotal_info.get('response_code', None):
        malware.virustotalurl = virustotal_info.get('permalink', '')
        malware.md5 = virustotal_info.get('md5', '')
        malware.sha1 = virustotal_info.get('sha1', '')
        malware.sha256 = virustotal_info.get('sha256', '')

        if virustotal_info.get('scan_date', None):
            malware.firstseen = datetime.strptime(virustotal_info.get('scan_date'), "%Y-%m-%d %H:%M:%S").date()
        if virustotal_info.get('positives', None) and virustotal_info.get('total', None):
            malware.detectionrate = virustotal_info.get('positives') / (virustotal_info.get('total') * 1.0)

        malware.save()

    # update virus total info
    if virustotal_info.get('scans', {}):
        for vendor, vendor_info in virustotal_info.get('scans', {}).items():

            if vendor_info.get('update', None):
                update_date = datetime.strptime(vendor_info.get('update', ""), "%Y%m%d").date()

            default_conetent = {
                "vendor": vendor,
                "md5": virustotal_info.get('md5', ""),
                "version": vendor_info.get('version', ""),
                "detected": vendor_info.get('detected', ""),
                "label": vendor_info.get('result', "null"),
                "update_date": update_date if vendor_info.get('update', None) else None,
                "malware": malware,
                }

            VirusTotalInfo.objects.update_or_create(vendor=vendor, virus_total=virus_total, defaults=default_conetent,)

r
